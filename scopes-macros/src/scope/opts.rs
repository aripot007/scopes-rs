#[cfg(feature = "hierarchy")]
use darling::FromMeta;
use darling::{FromDeriveInput, FromVariant, ast};

// Options for the enum to be derived
#[derive(FromDeriveInput)]
#[darling(attributes(scope), supports(enum_unit))]
pub struct ScopeOpts {
    pub ident: syn::Ident,
    pub vis: syn::Visibility,

    #[darling(default = || ".".to_string())]
    pub separator: String,

    #[darling(default)]
    pub prefix: String,

    #[cfg(feature = "hierarchy")]
    #[darling(default = || true)]
    pub hierarchy: bool,

    // Add a function to get the scope name
    #[darling(default = || false)]
    pub scope_name_getter: bool,

    pub data: ast::Data<ScopeVariantOpts, ()>,
}

// Options for an enum variant of the scope enum
#[derive(Debug, FromVariant)]
#[darling(attributes(scope))]
pub struct ScopeVariantOpts {
    pub ident: syn::Ident,

    pub rename: Option<String>,

    #[cfg(feature = "hierarchy")]
    pub include: Option<IncludeList>,
}

#[cfg(test)]
impl Default for ScopeVariantOpts {
    fn default() -> Self {
        Self { 
            ident: syn::parse_quote!(Foo), 
            rename: Default::default(),
            #[cfg(feature = "hierarchy")]
            include: Default::default()
        }
    }
}

#[cfg(feature = "hierarchy")]
#[derive(Debug)]
pub struct IncludeList(pub Vec<syn::Ident>);

#[cfg(feature = "hierarchy")]
impl FromMeta for IncludeList {

    fn from_expr(expr: &syn::Expr) -> darling::Result<Self> {

        match *expr {
            syn::Expr::Lit(ref lit) => Self::from_value(&lit.lit),
            syn::Expr::Group(ref group) => {
                // syn may generate this invisible group delimiter when the input to the darling
                // proc macro (specifically, the attributes) are generated by a
                // macro_rules! (e.g. propagating a macro_rules!'s expr)
                // Since we want to basically ignore these invisible group delimiters,
                // we just propagate the call to the inner expression.
                Self::from_expr(&group.expr)
            },

            // Single scope
            syn::Expr::Path(_) => Ok(IncludeList(vec![parse_included_scope(expr)?])),

            // List of included scopes
            syn::Expr::Array(syn::ExprArray { ref elems, ..})
            | syn::Expr::Tuple(syn::ExprTuple { ref elems, .. }) => {
                
                // Parse each expression in the list
                let parsed_elems: Vec<syn::Ident> = elems.iter()
                    .map(parse_included_scope)

                    // Fold into a vec or combine errors
                    .fold(Ok(Vec::new()), |acc, r| match (acc, r) {
                        (Ok(mut elts), Ok(e)) => {
                            elts.push(e);
                            Ok(elts)
                        },
                        (Ok(_), Err(e)) => Err(vec![e]),
                        (Err(acc), Ok(_)) => Err(acc),
                        (Err(mut acc), Err(e)) => {
                            acc.push(e);
                            Err(acc)
                        },
                    })
                    .map_err(darling::Error::multiple)?;

                Ok(IncludeList(parsed_elems))
            },

            _ => Err(darling::Error::unexpected_expr_type(expr)),
        }
        .map_err(|e| e.with_span(expr))
    }
}

#[cfg(feature = "hierarchy")]
fn parse_included_scope(expr: &syn::Expr) -> Result<syn::Ident, darling::Error> {
    use syn::spanned::Spanned;

    
    let syn::ExprPath { path, .. } = match expr {
        syn::Expr::Path(p) => p,
        _ => return Err(darling::Error::unexpected_expr_type(expr)),
    };

    let variant_name = match path.segments.len() {
        1 => &path.segments[0],
        2 => &path.segments[1],
        _ => return Err(darling::Error::custom("Expected an enum variant like `MyEnum::Variant` or `Variant`").with_span(&expr.span()))
    };

    Ok(variant_name.ident.clone())
}

