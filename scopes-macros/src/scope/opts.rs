#[cfg(feature = "hierarchy")]
use darling::FromMeta;
use darling::{FromDeriveInput, FromVariant, ast};

// Options for the enum to be derived
#[derive(FromDeriveInput)]
#[darling(attributes(scope), supports(enum_unit))]
pub struct ScopeOpts {
    pub ident: syn::Ident,
    pub vis: syn::Visibility,

    #[darling(default = || ".".to_string())]
    pub separator: String,

    #[darling(default)]
    pub prefix: String,

    #[cfg(feature = "hierarchy")]
    #[darling(default = || true)]
    pub hierarchy: bool,

    // Add a function to get the scope name
    #[darling(default = || false)]
    pub scope_name_getter: bool,

    pub data: ast::Data<ScopeVariantOpts, ()>,
}

// Options for an enum variant of the scope enum
#[derive(Debug, FromVariant)]
#[darling(attributes(scope))]
pub struct ScopeVariantOpts {
    pub ident: syn::Ident,

    pub rename: Option<String>,

    #[cfg(feature = "hierarchy")]
    pub include: Option<IncludeList>,
}

#[cfg(test)]
impl Default for ScopeVariantOpts {
    fn default() -> Self {
        Self { 
            ident: syn::parse_quote!(Foo), 
            rename: Default::default(),
            #[cfg(feature = "hierarchy")]
            include: Default::default()
        }
    }
}

#[cfg(feature = "hierarchy")]
#[derive(Debug)]
pub struct IncludeList(pub Vec<syn::Ident>);

#[cfg(feature = "hierarchy")]
impl FromMeta for IncludeList {

    fn from_expr(expr: &syn::Expr) -> darling::Result<Self> {

        match *expr {
            syn::Expr::Lit(ref lit) => Self::from_value(&lit.lit),
            syn::Expr::Group(ref group) => {
                // syn may generate this invisible group delimiter when the input to the darling
                // proc macro (specifically, the attributes) are generated by a
                // macro_rules! (e.g. propagating a macro_rules!'s expr)
                // Since we want to basically ignore these invisible group delimiters,
                // we just propagate the call to the inner expression.
                Self::from_expr(&group.expr)
            },

            // Single scope
            syn::Expr::Path(_) => Ok(IncludeList(vec![parse_included_scope(expr)?])),

            // List of included scopes
            syn::Expr::Array(syn::ExprArray { ref elems, ..})
            | syn::Expr::Tuple(syn::ExprTuple { ref elems, .. }) => {
                
                // Parse each expression in the list
                let parsed_elems: Vec<syn::Ident> = elems.iter()
                    .map(parse_included_scope)

                    // Fold into a vec or combine errors
                    .fold(Ok(Vec::new()), |acc, r| match (acc, r) {
                        (Ok(mut elts), Ok(e)) => {
                            elts.push(e);
                            Ok(elts)
                        },
                        (Ok(_), Err(e)) => Err(vec![e]),
                        (Err(acc), Ok(_)) => Err(acc),
                        (Err(mut acc), Err(e)) => {
                            acc.push(e);
                            Err(acc)
                        },
                    })
                    .map_err(darling::Error::multiple)?;

                Ok(IncludeList(parsed_elems))
            },

            _ => Err(darling::Error::unexpected_expr_type(expr)),
        }
        .map_err(|e| e.with_span(expr))
    }
}

#[cfg(feature = "hierarchy")]
fn parse_included_scope(expr: &syn::Expr) -> Result<syn::Ident, darling::Error> {
    use syn::spanned::Spanned;

    
    let syn::ExprPath { path, .. } = match expr {
        syn::Expr::Path(p) => p,
        _ => return Err(darling::Error::unexpected_expr_type(expr)),
    };

    let variant_name = match path.segments.len() {
        1 => &path.segments[0],
        2 => &path.segments[1],
        _ => return Err(darling::Error::custom("Expected an enum variant like `MyEnum::Variant` or `Variant`").with_span(&expr.span()))
    };

    Ok(variant_name.ident.clone())
}

#[cfg(test)]
mod tests {
    #[cfg(feature = "hierarchy")]
    use darling::FromMeta;
    #[cfg(feature = "hierarchy")]
    use syn::parse_quote;

    #[cfg(feature = "hierarchy")]
    use crate::scope::opts::{parse_included_scope, IncludeList};

    #[cfg(feature = "hierarchy")]
    macro_rules! ident {
        ($i: ident) => {
            {let ident: syn::Ident = parse_quote!($i); ident}
        };
    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_included_scope_variant_only() {
        let expr: syn::Expr = parse_quote! {Foo};

        let expected: syn::Ident = parse_quote!(Foo);

        assert_eq!(parse_included_scope(&expr).unwrap(), expected);
    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_included_scope_variant_full() {
        let expr: syn::Expr = parse_quote! {MyScope::Foo};

        let expected: syn::Ident = parse_quote!(Foo);

        assert_eq!(parse_included_scope(&expr).unwrap(), expected);
    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_included_scope_path_too_long() {
        let expr: syn::Expr = parse_quote! {crate::MyScope::Foo};

        assert!(parse_included_scope(&expr).is_err());
    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_included_scope_invalid_type() {

        assert!(parse_included_scope(&parse_quote! {"foo"}).is_err());
        assert!(parse_included_scope(&parse_quote! {[Foo,]}).is_err());
        assert!(parse_included_scope(&parse_quote! {(Foo,)}).is_err());

    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_include_single_scope() {
        assert_eq!(IncludeList::from_expr(&parse_quote! {MyScope::Foo}).unwrap().0, vec![ident!(Foo)]);
        assert_eq!(IncludeList::from_expr(&parse_quote! {Bar}).unwrap().0, vec![ident!(Bar)]);
    }

    #[cfg(feature = "hierarchy")]
    #[test]
    fn test_parse_include_multiple_scopes() {
        
        let parsed_array = IncludeList::from_expr(&parse_quote! {[Foo, MyScope::Bar, Baz]}).unwrap().0;
        let parsed_tuple = IncludeList::from_expr(&parse_quote! {(Foo, MyScope::Bar, Baz)}).unwrap().0;

        assert_eq!(parsed_array, vec![ident!(Foo), ident!(Bar), ident!(Baz)]);
        assert_eq!(parsed_array, parsed_tuple);
    }
}
